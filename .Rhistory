library(tictoc)
tic("hui_sim")
# your code here
results <- replicate(500,
hui.sim(
class0 = 250
, class1 = 250 #count in class =1
,p1_0 = 0.2     # 1 - sp test 1
,p1_1 = 0.8     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.8     # se test 2
,n_synth = 500 # n for the tvae
, p_class1 = 0.8 # class proportion for the tvae
, epochs = 100  #number of training epochs
))
library(reshape2)
results_df <- melt(results)
names(results_df)<-c("source", "stat","iteration","value")
#summarize the simulation
results_summary <- results_df |> group_by(source,stat) %>%
summarise(
lower = quantile(value, 0.025),  # 2.5th percentile
median_val = median(value),
upper = quantile(value, 0.975),  # 97.5th percentile
.groups = "drop"
) |> arrange(stat)
# print it nicely
n  <- nrow(results_summary)
pair_odd      <- which(gl(n, 2, labels = FALSE) %% 2 == 1)  # rows 1–2, 5–6, ...
last_in_pair  <- seq(2, n, by = 2)                          # 2, 4, 6, ...
kbl(results_summary) %>%
# Shade odd-numbered pairs
row_spec(pair_odd, background = "#A0A0A0", color = "black") %>%
# Thick divider after each pair so blocks don’t visually run together
row_spec(last_in_pair, extra_css = "border-bottom: 3px solid #000;") %>%
kable_styling(full_width = FALSE)
toc()
582/60
500*.7
results_summary_n_500 <- results_summary
library(tictoc)
tic("hui_sim")
# your code here
results <- replicate(500,
hui.sim(
class0 = 150  #count in class=0
, class1 = 350 #count in class =1
,p1_0 = 0.1     # 1 - sp test 1
,p1_1 = 0.9     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.9     # se test 2
,n_synth = 500 # n for the tvae
, p_class1 = 0.3 # class proportion for the tvae
, epochs = 100  #number of training epochs
))
library(reshape2)
results_df <- melt(results)
names(results_df)<-c("source", "stat","iteration","value")
#summarize the simulation
results_summary <- results_df |> group_by(source,stat) %>%
summarise(
lower = quantile(value, 0.025),  # 2.5th percentile
median_val = median(value),
upper = quantile(value, 0.975),  # 97.5th percentile
.groups = "drop"
) |> arrange(stat)
# print it nicely
n  <- nrow(results_summary)
pair_odd      <- which(gl(n, 2, labels = FALSE) %% 2 == 1)  # rows 1–2, 5–6, ...
last_in_pair  <- seq(2, n, by = 2)                          # 2, 4, 6, ...
kbl(results_summary) %>%
# Shade odd-numbered pairs
row_spec(pair_odd, background = "#A0A0A0", color = "black") %>%
# Thick divider after each pair so blocks don’t visually run together
row_spec(last_in_pair, extra_css = "border-bottom: 3px solid #000;") %>%
kable_styling(full_width = FALSE)
toc()
560/60
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
hui.sim(
class0 = 150  #count in class=0
, class1 = 350 #count in class =1
,p1_0 = 0.1     # 1 - sp test 1
,p1_1 = 0.9     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.9     # se test 2
,n_synth = 500 # n for the tvae
, p_class1 = 0.3 # class proportion for the tvae
, epochs = 100  #number of training epochs
)
hui.sim()
hui.sim <- function(
class0 = 50
, class1 = 50 #count in class =1
,p1_0 = 0.2     # 1 - sp test 1
,p1_1 = 0.8     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.8     # se test 2
,n_synth = 50 # n for the tvae
, p_class1 = 0.8 # class proportion for the tvae
, epochs = 10  #number of training epochs
) {
#####"real" dataset
df <- generate_real_data(class0 = class0
, class1 = class1 #count in class =1
,p1_0 = p1_0 # 1 - sp test 1
,p1_1 = p1_1 #se test 1
,p2_0 = p2_0 # 1 -sp test 2
,p2_1 = p2_1) # se test 2
######generate synthetic dataset
synth.output <- tvae_synthesize_binary(df, n_synth = n_synth, p_class1 = p_class1, epochs = epochs)
##### hui and walter
hui <- hui_walter_mle_se(
table(df$test1,df$test2)
, table(synth.output$synthetic_df$test1,synth.output$synthetic_df$test2))
#######make the output
real.data<-c(as.vector(calc_se_sp(df)),mean(df$class),NA)
names(real.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
synthetic.data<-c(as.vector(calc_se_sp(synth.output)),NA,mean(synth.output$synthetic_df$class))
names(synthetic.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
hui.estimates <- hui$estimates
return(rbind(hui.estimates,real.data,synthetic.data))
}
hui.sim()
hui.sim <- function(
class0 = 50
, class1 = 50 #count in class =1
,p1_0 = 0.2     # 1 - sp test 1
,p1_1 = 0.8     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.8     # se test 2
,n_synth = 50 # n for the tvae
, p_class1 = 0.8 # class proportion for the tvae
, epochs = 10  #number of training epochs
) {
#####"real" dataset
df <- generate_real_data(class0 = class0
, class1 = class1 #count in class =1
,p1_0 = p1_0 # 1 - sp test 1
,p1_1 = p1_1 #se test 1
,p2_0 = p2_0 # 1 -sp test 2
,p2_1 = p2_1) # se test 2
######generate synthetic dataset
synth.output <- tvae_synthesize_binary(df, n_synth = n_synth, p_class1 = p_class1, epochs = epochs)
##### hui and walter
hui <- hui_walter_mle_se(
table(df$test1,df$test2)
, table(synth.output$synthetic_df$test1,synth.output$synthetic_df$test2))
#######make the output
real.data<-c(as.vector(calc_se_sp(df)),mean(df$class),NA)
names(real.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
print(real.dat )
synthetic.data<-c(as.vector(calc_se_sp(synth.output)),NA,mean(synth.output$synthetic_df$class))
names(synthetic.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
print(synthetic.data)
hui.estimates <- hui$estimates
return(rbind(hui.estimates,real.data,synthetic.data))
}
hui.sim()
hui.sim <- function(
class0 = 500
, class1 = 500 #count in class =1
,p1_0 = 0.2     # 1 - sp test 1
,p1_1 = 0.8     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.8     # se test 2
,n_synth = 500 # n for the tvae
, p_class1 = 0.8 # class proportion for the tvae
, epochs = 10  #number of training epochs
) {
#####"real" dataset
df <- generate_real_data(class0 = class0
, class1 = class1 #count in class =1
,p1_0 = p1_0 # 1 - sp test 1
,p1_1 = p1_1 #se test 1
,p2_0 = p2_0 # 1 -sp test 2
,p2_1 = p2_1) # se test 2
######generate synthetic dataset
synth.output <- tvae_synthesize_binary(df, n_synth = n_synth, p_class1 = p_class1, epochs = epochs)
##### hui and walter
hui <- hui_walter_mle_se(
table(df$test1,df$test2)
, table(synth.output$synthetic_df$test1,synth.output$synthetic_df$test2))
#######make the output
real.data<-c(as.vector(calc_se_sp(df)),mean(df$class),NA)
names(real.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
print(real.dat )
synthetic.data<-c(as.vector(calc_se_sp(synth.output)),NA,mean(synth.output$synthetic_df$class))
names(synthetic.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
print(synthetic.data)
hui.estimates <- hui$estimates
return(rbind(hui.estimates,real.data,synthetic.data))
}
hui.sim()
hui.sim <- function(
class0 = 500
, class1 = 500 #count in class =1
,p1_0 = 0.2     # 1 - sp test 1
,p1_1 = 0.8     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.8     # se test 2
,n_synth = 500 # n for the tvae
, p_class1 = 0.8 # class proportion for the tvae
, epochs = 10  #number of training epochs
) {
#####"real" dataset
df <- generate_real_data(class0 = class0
, class1 = class1 #count in class =1
,p1_0 = p1_0 # 1 - sp test 1
,p1_1 = p1_1 #se test 1
,p2_0 = p2_0 # 1 -sp test 2
,p2_1 = p2_1) # se test 2
######generate synthetic dataset
synth.output <- tvae_synthesize_binary(df, n_synth = n_synth, p_class1 = p_class1, epochs = epochs)
##### hui and walter
hui <- hui_walter_mle_se(
table(df$test1,df$test2)
, table(synth.output$synthetic_df$test1,synth.output$synthetic_df$test2))
#######make the output
real.data<-c(as.vector(calc_se_sp(df)),mean(df$class),NA)
names(real.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
print(real.data)
synthetic.data<-c(as.vector(calc_se_sp(synth.output)),NA,mean(synth.output$synthetic_df$class))
names(synthetic.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
print(synthetic.data)
hui.estimates <- hui$estimates
return(rbind(hui.estimates,real.data,synthetic.data))
}
hui.sim()
hui.sim <- function(
class0 = 500
, class1 = 500 #count in class =1
,p1_0 = 0.2     # 1 - sp test 1
,p1_1 = 0.8     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.8     # se test 2
,n_synth = 500 # n for the tvae
, p_class1 = 0.8 # class proportion for the tvae
, epochs = 10  #number of training epochs
) {
#####"real" dataset
df <- generate_real_data(class0 = class0
, class1 = class1 #count in class =1
,p1_0 = p1_0 # 1 - sp test 1
,p1_1 = p1_1 #se test 1
,p2_0 = p2_0 # 1 -sp test 2
,p2_1 = p2_1) # se test 2
######generate synthetic dataset
synth.output <- tvae_synthesize_binary(df, n_synth = n_synth, p_class1 = p_class1, epochs = epochs)
##### hui and walter
hui <- hui_walter_mle_se(
table(df$test1,df$test2)
, table(synth.output$synthetic_df$test1,synth.output$synthetic_df$test2))
#######make the output
real.data<-c(as.vector(calc_se_sp(df)),mean(df$class),NA)
names(real.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
print(real.data)
synthetic.data<-c(as.vector(calc_se_sp(synth.output$synthetic_df)),NA,mean(synth.output$synthetic_df$class))
names(synthetic.data)<-c("Se1" ,"Sp1", "Se2" ,"Sp2"   ,  "Prev_pop1", "Prev_pop2")
print(synthetic.data)
hui.estimates <- hui$estimates
return(rbind(hui.estimates,real.data,synthetic.data))
}
hui.sim()
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
results <- replicate(5,
hui.sim(
class0 = 150  #count in class=0
, class1 = 350 #count in class =1
,p1_0 = 0.1     # 1 - sp test 1
,p1_1 = 0.9     #se test 1
,p2_0 = 0.10    # 1 -sp test 2
,p2_1 = 0.9     # se test 2
,n_synth = 500 # n for the tvae
, p_class1 = 0.3 # class proportion for the tvae
, epochs = 100  #number of training epochs
))
results_df
library(reshape2)
results_df <- melt(results)
names(results_df)<-c("source", "stat","iteration","value")
results_df
results_df
results
library(reshape2)
results_df <- melt(results)
results_df
print(results_df)
is.array(results)
melt(results)
library(reshape2)
results_df <- melt(results)
names(results_df)<-c("source", "stat","iteration","value")
#summarize the simulation
results_summary <- results_df |> group_by(source,stat) %>%
summarise(
lower = quantile(value, 0.025),  # 2.5th percentile
median_val = median(value),
upper = quantile(value, 0.975),  # 97.5th percentile
.groups = "drop"
) |> arrange(stat)
#summarize the simulation
results_summary <- results_df |> group_by(source,stat) %>%
summarise(
lower = quantile(value, 0.025,na.rm=TRUE),  # 2.5th percentile
median_val = median(value,na.rm=TRUE),
upper = quantile(value, 0.975,na.rm=TRUE),  # 97.5th percentile
.groups = "drop"
) |> arrange(stat)
results_summary
# print it nicely
n <- nrow(results_summary)
# indices for every 3-row block
triplet_odd     <- which(gl(n, 3, labels = FALSE) %% 2 == 1)  # rows 1–3, 7–9, ...
last_in_triplet <- seq(3, n, by = 3)                          # 3, 6, 9, ...                     # 2, 4, 6, ...
kbl(results_summary) %>%
# Shade odd-numbered pairs
row_spec(pair_odd, background = "#A0A0A0", color = "black") %>%
# Thick divider after each pair so blocks don’t visually run together
row_spec(last_in_pair, extra_css = "border-bottom: 3px solid #000;") %>%
kable_styling(full_width = FALSE)
# rows belonging to odd-numbered 3-row blocks: 1–3, 7–9, ...
triplet_odd <- which(gl(n, 3, labels = FALSE) %% 2 == 1)
# put a divider after each 3rd row; also after the last row if n %% 3 != 0
dividers <- seq(3, n, by = 3)
if (n %% 3 != 0) dividers <- c(dividers, n)
kbl(results_summary) %>%
# shade odd-numbered triplets
row_spec(triplet_odd, background = "#A0A0A0", color = "black") %>%
# thick divider after each triplet (and at end if partial)
row_spec(dividers, extra_css = "border-bottom: 3px solid #000;") %>%
kable_styling(full_width = FALSE)
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
round(500.2)
as.integer(500.2)
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
sim_summary_table(resuls)
sim_summary_table(results)
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
sim_summary_table(results)$table
sim_summary_table(results)
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
sim_summary_table(results)
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
sim_summary_table(results)
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
sim_summary_table(results)
sim_summary_table(results)$table
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
sim_summary_table(results)$table
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
library(tictoc)
tic("time_hui_sim")
results <- replicate(500,
hui.sim(
p_class1_real = 0.7 # class proportion for the "real" training set
,p_class1 =      0.3 # class proportion for the synth
,n_real =        500 # n for the "real" training set
,n_synth =       500 # n for the tvae
,p1_0 =          0.1     # 1 - sp test 1
,p1_1 =          0.9     #se test 1
,p2_0 =          0.2    # 1 -sp test 2
,p2_1 =          0.8     # se test 2
, epochs =       200  #number of training epochs
))
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
library(tictoc)
tic("time_hui_sim")
results <- replicate(500,
hui.sim(
p_class1_real = 0.7 # class proportion for the "real" training set
,p_class1 =      0.3 # class proportion for the synth
,n_real =        500 # n for the "real" training set
,n_synth =       500 # n for the tvae
,p1_0 =          0.1     # 1 - sp test 1
,p1_1 =          0.9     #se test 1
,p2_0 =          0.2    # 1 -sp test 2
,p2_1 =          0.8     # se test 2
, epochs =       200  #number of training epochs
))
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
library(tictoc)
tic("time_hui_sim")
results <- replicate(500,
hui.sim(
p_class1_real = 0.7 # class proportion for the "real" training set
,p_class1 =      0.3 # class proportion for the synth
,n_real =        500 # n for the "real" training set
,n_synth =       500 # n for the tvae
,p1_0 =          0.1     # 1 - sp test 1
,p1_1 =          0.9     #se test 1
,p2_0 =          0.2    # 1 -sp test 2
,p2_1 =          0.8     # se test 2
, epochs =       200  #number of training epochs
))
#make the results into a nice table
sim_summary_table(results)$table
toc()
1068/60
check_dep <- function(df) {
by(df, df$class, function(d) {
# phi is cor for 0/1; chisq test gives association too
phi <- suppressWarnings(cor(d$test1, d$test2))
chisq_p <- chisq.test(table(d$test1, d$test2))$p.value
c(phi = phi, chisq_p = chisq_p)
})
}
check_dep(synthetic_df)
break_dep_by_permutation <- function(df) {
stopifnot(all(c("class","test1","test2") %in% names(df)))
out <- df
for (k in 0:1) {
idx <- which(df$class == k)
if (length(idx) > 1) {
# independently permute each test within the class stratum
out$test1[idx] <- sample(df$test1[idx])
out$test2[idx] <- sample(df$test2[idx])
}
}
out
}
break_dep_by_permutation(check_dep(synthetic_df))
names(synthetic_df)
break_dep_by_permutation(check_dep(synthetic_df))
check_dep(break_dep_by_permutation(synthetic_df))
check_dep(synthetic_df)
# Train set CI check
by(df, train_df$class, \(d) fisher.test(table(d$test1, d$test2))$p.value)
# Train set CI check
by(df, df$class, \(d) fisher.test(table(d$test1, d$test2))$p.value)
# Synthetic set CI check
by(synth_df, synth_df$class, \(d) fisher.test(table(d$test1, d$test2))$p.value)
# Synthetic set CI check
by(synthetic_df, synthetic_df$class, \(d) fisher.test(table(d$test1, d$test2))$p.value)
# Or estimate within-class phi/odds ratio
by(synthetic_df, synthetic_df$class, \(d) {
tab <- table(d$test1, d$test2)
phi <- suppressWarnings(cor(d$test1, d$test2))
OR  <- (tab[2,2]*tab[1,1]) / (tab[1,2]*tab[2,1] + 1e-9)
c(phi = phi, OR = OR)
})
#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
library(tictoc)
tic("time_hui_sim")
results <- replicate(5,
hui.sim(
p_class1_real = 0.7 # class proportion for the "real" training set
,p_class1 =      0.3 # class proportion for the synth
,n_real =        500 # n for the "real" training set
,n_synth =       500 # n for the tvae
,p1_0 =          0.1     # 1 - sp test 1
,p1_1 =          0.9     #se test 1
,p2_0 =          0.2    # 1 -sp test 2
,p2_1 =          0.8     # se test 2
, epochs =       200  #number of training epochs
))
#make the results into a nice table
sim_summary_table(results)$table
toc()
library(tictoc)
tic("time_hui_sim")
results <- replicate(500,
hui.sim(
p_class1_real = 0.7 # class proportion for the "real" training set
,p_class1 =      0.3 # class proportion for the synth
,n_real =        500 # n for the "real" training set
,n_synth =       500 # n for the tvae
,p1_0 =          0.1     # 1 - sp test 1
,p1_1 =          0.9     #se test 1
,p2_0 =          0.2    # 1 -sp test 2
,p2_1 =          0.8     # se test 2
, epochs =       200  #number of training epochs
))
#make the results into a nice table
sim_summary_table(results)$table
toc()
library(tictoc)
tic("time_hui_sim")
results <- replicate(500,
hui.sim(
p_class1_real = 0.7 # class proportion for the "real" training set
,p_class1 =      0.3 # class proportion for the synth
,n_real =        500 # n for the "real" training set
,n_synth =       500 # n for the tvae
,p1_0 =          0.1     # 1 - sp test 1
,p1_1 =          0.9     #se test 1
,p2_0 =          0.2    # 1 -sp test 2
,p2_1 =          0.8     # se test 2
, epochs =       100  #number of training epochs
))
#make the results into a nice table
sim_summary_table(results)$table
toc()
