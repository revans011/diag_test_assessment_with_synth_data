---
title: "Analysis"
date: "`r Sys.Date()`"
author: "Rich Evans, PhD, PSTAT"
format: pdf
number-sections: true
execute: 
  echo: true
output-file: "analysis_results"
reticulate:
  python: "/Users/richardevans/.virtualenvs/r-reticulate/bin/python"
---

This runs everything


The upshot is that big training sets (n=10,000) work even when there are different class proportion (but not extreme) in the training set and the synthetic set. I need at least 5000 in the smallest class

Also, boundary se and sp are harder to get right. sp=.9 seems to go wrong for example

Also, a large training set means that fewer epochs are required.


what is interesting is that for small, n=1000 training sets, specificity always seems to fail first, regardless of large (p=0.75) or small (p=0.25). 


```{r}

#all the necessary functions
source(here::here("hui_tvae_functions2.R"))
```



```{r}

library(tictoc)

tic("time_hui_sim")

results <- replicate(500,  
  hui.sim(
     p_class1_real = 0.7 # class proportion for the "real" training set
    ,p_class1 =      0.3 # class proportion for the synth
    ,n_real =        500 # n for the "real" training set
    ,n_synth =       500 # n for the tvae
    ,p1_0 =          0.1     # 1 - sp test 1
    ,p1_1 =          0.9     #se test 1
    ,p2_0 =          0.2    # 1 -sp test 2
    ,p2_1 =          0.8     # se test 2  
    , epochs =       200  #number of training epochs
  ))


#make the results into a nice table
sim_summary_table(results)$table

toc()
```




```{r}
# --- Fix for joblib/loky resource_tracker warnings on restart ---
# These appear when reticulate's embedded Python shuts down and finds leftover semaphores or temp memmaps.
# This block sets up a stable temp dir, safe parallel backend, and silent teardown.

# Create a stable temp folder for joblib
dir.create("~/tmp/joblib", recursive = TRUE, showWarnings = FALSE)
Sys.setenv(JOBLIB_TEMP_FOLDER = "~/tmp/joblib")

# Optionally upgrade joblib/loky for better cleanup behavior
if (requireNamespace("reticulate", quietly = TRUE)) {
  try(reticulate::py_install(
    c("joblib>=1.4", "loky>=3.5"),
    envname = "r-reticulate", pip = TRUE
  ))
}

# Define a Python-safe parallel example with clean exit
if (requireNamespace("reticulate", quietly = TRUE)) {
  reticulate::py_run_string("
import os
os.makedirs(os.getenv('JOBLIB_TEMP_FOLDER', '/tmp'), exist_ok=True)
from joblib import Parallel, delayed, parallel_backend

def work(i):
    # example workload
    return i*i

# Use threading backend (no semaphores)
with parallel_backend('threading'):
    OUT = Parallel(n_jobs=-1)(delayed(work)(i) for i in range(1000))

# Clean shutdown of workers
import multiprocessing as mp
for p in mp.active_children():
    p.terminate()
")
  out <- reticulate::py$OUT
  print(str(out))
}

# Optional: silence resource_tracker warnings entirely (use sparingly)
Sys.setenv(PYTHONWARNINGS = "ignore:resource_tracker")

# Summary:
# - Prevents leaked semaphore warnings at R shutdown.
# - Keeps joblib temp files in one reusable folder.
# - Uses threads for safety (no process semaphores).
# - Safe to keep in .Rprofile or call before running reticulate simulations.
```

